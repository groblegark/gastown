# OCI image builds for gastown services — RWX native (no Dockerfiles).
#
# Uses $RWX_IMAGE for image metadata instead of inline Dockerfiles.
# The build VM uses rwx/base 1.0.0; the $RWX_IMAGE output defines
# the final container filesystem and metadata.
#
# Architecture:
#   build-* tasks → compile binaries as artifacts (cached by filters)
#   image-*  tasks → install runtime deps + configure $RWX_IMAGE metadata
#   push-*   tasks → crane-append layers to ubuntu:24.04, push to GHCR
#
# Push is automated on main/tags. For manual push of a single image:
#   rwx run .rwx/docker.yml --init commit-sha=$(git rev-parse HEAD) --target push-agent
#
# VERSIONING:
# All component versions are pinned in platform-versions.env (repo root).
# All images are tagged with PLATFORM_VERSION (CalVer: YYYY.MM.DD.N).
# To rebuild: bump versions in platform-versions.env, commit, run:
#   rwx run .rwx/docker.yml --init commit-sha=$(git rev-parse HEAD) --wait
#
# OPTIMIZATIONS:
# - Filter directives on Go mod downloads (cached by go.mod/go.sum)
# - Parallel builds with filter caching for dependency stability
# - RWX native layer caching replaces Docker BuildKit

on:
  github:
    push:
      if: ${{ event.git.branch == 'main' || starts-with(event.git.tag, 'v') }}
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: ${{ event.git.ref }}
        beads-version: ""
      status-checks:
        name: Docker
    pull_request:
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: pr
        beads-version: ""
      status-checks:
        - tasks: [build-gt, build-controller, download-coop, download-bd]
          name: Docker
  dispatch:
    - key: gastown-agent-rebuild
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: ${{ event.dispatch.params.trigger-source }}
        beads-version: ${{ event.dispatch.params.beads-version }}
        coop-version: ${{ event.dispatch.params.coop-version }}
      params:
        - key: trigger-source
          name: Trigger source
          description: What triggered the rebuild (e.g. coop-release, beads-release)
          default: manual
          required: false
        - key: beads-version
          name: Beads version
          description: Beads version tag to use (e.g. v0.62.7). Overrides platform-versions.env when set.
          default: ""
          required: false
        - key: coop-version
          name: Coop version
          description: Coop version tag to use (e.g. v0.12.4). Overrides platform-versions.env when set.
          default: ""
          required: false
      title: Agent rebuild (${{ init.ref-name }})
      # NOTE: No target — dispatch runs the full pipeline including push-* tasks.
      # Do NOT add "target: image-agent" here — it prevents GHCR pushes.
  cli:
    init:
      commit-sha: ${{ event.git.sha }}
      ref-name: cli
      beads-version: ""
      coop-version: ""

base:
  image: ubuntu:24.04
  config: rwx/base 1.0.0

tasks:
  # ═══════════════════════════════════════════════════════════════════════
  # Build tasks — compile and download in parallel, output binary artifacts
  # ═══════════════════════════════════════════════════════════════════════

  # ── Clone gastown repo ─────────────────────────────────────────────
  - key: code
    call: git/clone 2.0.3
    with:
      repository: https://github.com/groblegark/gastown.git
      ref: ${{ init.commit-sha }}

  # ── Go toolchain (version from .go-version) ───────────────────────
  - key: go
    call: golang/install 1.2.0
    with:
      go-version: "1.25"

  # ── Go mod download (cached by go.mod/go.sum) ──────────────────────
  - key: go-deps
    use: [code, go]
    run: go mod download
    filter:
      - go.mod
      - go.sum

  # ── Build gt CLI binary → artifact ──────────────────────────────────
  # Reads GASTOWN_VERSION and PLATFORM_VERSION from platform-versions.env
  # for ldflags so `gt version` reports the correct version.
  - key: build-gt
    use: [go-deps]
    cache: false
    run: |
      source platform-versions.env
      CGO_ENABLED=0 GOOS=linux go build \
        -ldflags="-s -w \
          -X github.com/steveyegge/gastown/internal/cmd.Version=${GASTOWN_VERSION} \
          -X github.com/steveyegge/gastown/internal/cmd.Commit=${COMMIT_SHA} \
          -X github.com/steveyegge/gastown/internal/cmd.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
          -X github.com/steveyegge/gastown/internal/cmd.PlatformVersion=${PLATFORM_VERSION} \
          -X github.com/steveyegge/gastown/internal/cmd.BuiltProperly=1" \
        -o gt ./cmd/gt
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
    outputs:
      artifacts:
        - key: gt-binary
          path: gt

  # ── Build controller binary → artifact (separate Go module) ─────────
  - key: build-controller
    use: [code, go]
    run: |
      source platform-versions.env
      cd controller
      go mod download
      CGO_ENABLED=0 GOOS=linux go build \
        -ldflags="-s -w -X main.version=${PLATFORM_VERSION} -X main.commit=${COMMIT_SHA}" \
        -o ../controller-bin ./cmd/controller/
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
    filter:
      - controller/**/*.go
      - controller/go.mod
      - controller/go.sum
      - platform-versions.env
    outputs:
      artifacts:
        - key: controller-binary
          path: controller-bin

  # ── Download coop from releases → artifact (pinned by platform-versions.env) ─
  # When dispatched from a coop release, init.coop-version overrides the
  # pinned version so the agent image always gets the just-released binary.
  - key: download-coop
    use: code
    run: |
      set -ex
      source platform-versions.env
      # Dispatch override: use the version from the triggering coop release
      if [ -n "${COOP_VERSION_OVERRIDE}" ]; then
        COOP_VERSION="${COOP_VERSION_OVERRIDE}"
        echo "Using dispatch override: COOP_VERSION=${COOP_VERSION}"
      fi
      echo "Downloading coop ${COOP_VERSION} for linux-amd64"
      curl -fsSL "https://github.com/groblegark/coop/releases/download/${COOP_VERSION}/coop-linux-amd64.tar.gz" \
        -o /tmp/coop.tar.gz
      mkdir -p coop-bin
      tar -xzf /tmp/coop.tar.gz -C coop-bin
      ls -la coop-bin/
    env:
      COOP_VERSION_OVERRIDE: ${{ init.coop-version }}
    filter:
      - platform-versions.env
    outputs:
      artifacts:
        - key: coop-binaries
          path: coop-bin

  # ── Download bd from releases → artifact (pinned by platform-versions.env) ──
  # When dispatched from a beads release, init.beads-version overrides the
  # pinned version so the agent image always gets the just-released binary.
  - key: download-bd
    use: code
    run: |
      set -ex
      source platform-versions.env
      # Dispatch override: use the version from the triggering beads release
      if [ -n "${BEADS_VERSION_OVERRIDE}" ]; then
        BEADS_VERSION="${BEADS_VERSION_OVERRIDE}"
        echo "Using dispatch override: BEADS_VERSION=${BEADS_VERSION}"
      fi
      VERSION_NUM=${BEADS_VERSION#v}
      echo "Downloading bd ${BEADS_VERSION} for linux_amd64"
      curl -fsSL "https://github.com/groblegark/beads/releases/download/${BEADS_VERSION}/beads_${VERSION_NUM}_linux_amd64.tar.gz" \
        -o /tmp/bd.tar.gz
      mkdir -p bd-bin
      tar -xzf /tmp/bd.tar.gz -C bd-bin
      ls -la bd-bin/
    env:
      BEADS_VERSION_OVERRIDE: ${{ init.beads-version }}
    filter:
      - platform-versions.env
    outputs:
      artifacts:
        - key: bd-binaries
          path: bd-bin

  # ═══════════════════════════════════════════════════════════════════════
  # Image tasks — RWX native images via $RWX_IMAGE.
  # These define the container filesystem and metadata.
  # Push via: rwx image build -f .rwx/docker.yml --target <key> --push-to <registry>
  # ═══════════════════════════════════════════════════════════════════════

  # ── gt CLI image (ubuntu + git + binary) ───────────────────────────
  - key: image-gt
    use: [build-gt]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - cmd/gt/**/*.go
      - internal/**/*.go
      - go.mod
      - go.sum
    run: |
      # Install minimal runtime deps
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends ca-certificates git
      sudo apt-get clean
      sudo rm -rf /var/lib/apt/lists/*

      # Install binary
      sudo cp ${{ tasks.build-gt.artifacts.gt-binary }} /usr/local/bin/gt
      sudo chmod 755 /usr/local/bin/gt

      # Configure image metadata (no sudo needed)
      jq -n '["gt"]' > $RWX_IMAGE/entrypoint.json
      echo "1000" > $RWX_IMAGE/user

  # ── Controller image (minimal static binary) ───────────────────────
  - key: image-controller
    use: [build-controller]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - controller/**/*.go
      - controller/go.mod
      - controller/go.sum
    run: |
      # Install binary
      sudo cp ${{ tasks.build-controller.artifacts.controller-binary }} /controller
      sudo chmod 755 /controller

      # Configure image metadata
      jq -n '["/controller"]' > $RWX_IMAGE/entrypoint.json
      echo "65534" > $RWX_IMAGE/user

  # ── Agent image (ubuntu + apt packages + gt/coop/bd/claude) ────────
  - key: image-agent
    use: [build-gt, download-coop, download-bd, code]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - deploy/agent/entrypoint.sh
      - .node-version
      - platform-versions.env
    run: |
      # WORKAROUND: Do NOT run apt-get update/install here.
      # On multi-layer overlayfs (4 dependency layers), apt-get update
      # corrupts /etc/shadow visibility, breaking all subsequent sudo calls.
      # The base image (rwx/base 1.0.0) already provides git, curl,
      # ca-certificates, and jq — verified by "0 newly installed" in logs.

      # Install Node.js from binary tarball (version from .node-version)
      NODE_VERSION=$(cat .node-version)
      curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
        | sudo tar -xJ --strip-components=1 -C /usr/local

      # Write platform version for runtime discovery (bd version, gt version)
      source platform-versions.env
      echo "${PLATFORM_VERSION}" | sudo tee /etc/platform-version > /dev/null

      # Install binaries
      sudo cp ${{ tasks.build-gt.artifacts.gt-binary }} /usr/local/bin/gt
      sudo cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop /usr/local/bin/coop
      sudo cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop-mux /usr/local/bin/coop-mux 2>/dev/null || true
      sudo cp ${{ tasks.download-bd.artifacts.bd-binaries }}/bd /usr/local/bin/bd
      sudo ln -sf /usr/local/bin/coop-mux /usr/local/bin/coopmux
      sudo chmod +x /usr/local/bin/gt /usr/local/bin/coop /usr/local/bin/bd \
        /usr/local/bin/coop-mux 2>/dev/null || true

      # Install entrypoint
      sudo cp deploy/agent/entrypoint.sh /entrypoint.sh
      sudo chmod +x /entrypoint.sh

      # Create home directory while we still have sudo
      sudo mkdir -p /home/agent/gt
      sudo chown -R 1000:1000 /home/agent

      # WORKAROUND: npm install -g and sed both corrupt /etc/shadow on
      # multi-layer overlayfs, breaking subsequent sudo calls. Run them
      # in a single sudo bash -c to avoid re-authentication.
      sudo bash -c '
        npm install -g @anthropic-ai/claude-code
        sed -i "s/^ubuntu:/agent:/" /etc/passwd
        sed -i "s|/home/ubuntu|/home/agent|" /etc/passwd
        sed -i "s/^ubuntu:/agent:/" /etc/group
      '

      # Configure image metadata (no sudo needed)
      jq -n '["/entrypoint.sh"]' > $RWX_IMAGE/entrypoint.json
      echo "agent" > $RWX_IMAGE/user
      echo "/home/agent/gt" > $RWX_IMAGE/workspace

  # ── Toolchain image (Go + Node + Python + AWS/RWX/kubectl + Docker CLI + gt/bd/coop) ──
  - key: image-toolchain
    use: [code, build-gt, download-coop, download-bd]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - .rwx/toolchain-version.lock
      - .go-version
      - .node-version
      - docker/toolchain/entrypoint.sh
      - platform-versions.env
    run: |
      export DEBIAN_FRONTEND=noninteractive
      source platform-versions.env
      export PLATFORM_VERSION

      # Export artifact paths so sudo -E can pass them into the bash -c block.
      export GT_BIN="${{ tasks.build-gt.artifacts.gt-binary }}"
      export COOP_DIR="${{ tasks.download-coop.artifacts.coop-binaries }}"
      export BD_DIR="${{ tasks.download-bd.artifacts.bd-binaries }}"

      # Run ALL apt and sudo operations in a single sudo bash -c block.
      # WORKAROUND: dpkg operations (apt-get install) corrupt /etc/shadow
      # on RWX overlayfs, breaking subsequent sudo re-authentication.
      # A single sudo session avoids re-auth after corruption.
      sudo -E bash -c '
        set -e

        # Base tools
        apt-get -y update
        apt-get -y install --no-install-recommends \
          curl git jq make unzip ca-certificates

        # Go (version from .go-version, installer resolves latest patch)
        GO_VERSION=$(cat .go-version)
        GO_LATEST=$(curl -fsSL "https://go.dev/dl/?mode=json" | jq -r "[.[] | select(.version | startswith(\"go${GO_VERSION}\"))][0].version")
        curl -fsSL "https://go.dev/dl/${GO_LATEST}.linux-amd64.tar.gz" | tar -C /usr/local -xz
        export PATH="/usr/local/go/bin:$PATH"
        GOPATH="/tmp/go" go install golang.org/x/tools/gopls@latest
        mv /tmp/go/bin/gopls /usr/local/go/bin/gopls
        rm -rf /tmp/go

        # Node.js (version from .node-version; binary tarball — nodesource apt triggers shadow corruption)
        NODE_VERSION=$(cat .node-version)
        curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
          | tar -xJ --strip-components=1 -C /usr/local

        # Python
        apt-get -y install --no-install-recommends \
          python3 python3-pip python3-venv
        ln -sf /usr/bin/python3 /usr/bin/python

        # AWS CLI
        curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
        unzip -q /tmp/awscli.zip -d /tmp
        /tmp/aws/install --install-dir /opt/aws-cli --bin-dir /opt/aws-cli/bin
        ln -sf /opt/aws-cli/bin/aws /usr/local/bin/aws
        rm -rf /tmp/awscli.zip /tmp/aws

        # Docker CLI (client only)
        curl -fsSL "https://download.docker.com/linux/static/stable/x86_64/docker-27.5.1.tgz" | \
          tar -xz --strip-components=1 -C /usr/local/bin docker/docker

        # Rust Analyzer
        curl -fsSL "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" | \
          gunzip | tee /usr/local/bin/rust-analyzer > /dev/null
        chmod +x /usr/local/bin/rust-analyzer

        # kubectl
        KUBECTL_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
        curl -fsSL "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" \
          -o /usr/local/bin/kubectl
        chmod +x /usr/local/bin/kubectl

        # RWX CLI
        curl -fsSL "https://github.com/rwx-cloud/cli/releases/latest/download/rwx-linux-x86_64" \
          -o /usr/local/bin/rwx
        chmod +x /usr/local/bin/rwx

        # Clean up apt
        apt-get clean
        rm -rf /var/lib/apt/lists/*

        # Install gt, coop, coopmux, bd binaries (from build artifacts)
        cp "${GT_BIN}" /usr/local/bin/gt
        cp "${COOP_DIR}/coop" /usr/local/bin/coop
        cp "${COOP_DIR}/coop-mux" /usr/local/bin/coop-mux 2>/dev/null || true
        cp "${BD_DIR}/bd" /usr/local/bin/bd
        ln -sf /usr/local/bin/coop-mux /usr/local/bin/coopmux
        chmod +x /usr/local/bin/gt /usr/local/bin/coop /usr/local/bin/bd \
          /usr/local/bin/coop-mux 2>/dev/null || true

        # Write platform version for runtime discovery
        echo "${PLATFORM_VERSION}" > /etc/platform-version

        # Install entrypoint and create home dir
        cp docker/toolchain/entrypoint.sh /usr/local/bin/toolchain-entrypoint.sh
        chmod +x /usr/local/bin/toolchain-entrypoint.sh
        mkdir -p /home/agent
        chown -R 1000:1000 /home/agent

        # Rename ubuntu→agent in passwd/group (breaks sudo for running process)
        sed -i "s/^ubuntu:/agent:/" /etc/passwd
        sed -i "s|/home/ubuntu|/home/agent|" /etc/passwd
        sed -i "s|/bin/sh|/bin/bash|" /etc/passwd
        sed -i "s/^ubuntu:/agent:/" /etc/group
      '

      # Configure image metadata (no sudo needed)
      echo "/usr/local/bin/toolchain-entrypoint.sh" > $RWX_IMAGE/command
      echo "1000:1000" > $RWX_IMAGE/user
      echo "/home/agent/gt" > $RWX_IMAGE/workspace

  # ═══════════════════════════════════════════════════════════════════════
  # Push tasks — crane-append layers to ubuntu:24.04, push to GHCR.
  # Each push task reuses build artifacts to create a minimal OCI image.
  # Secrets: GHCR_TOKEN and GITHUB_USER must be set in the RWX vault.
  # ═══════════════════════════════════════════════════════════════════════

  # ── Push controller image to GHCR ─────────────────────────────────────
  - key: push-controller
    use: [code, build-controller]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      # Build layer: static binary + CA certs
      mkdir -p /tmp/layer/etc/ssl/certs
      cp ${{ tasks.build-controller.artifacts.controller-binary }} /tmp/layer/controller
      chmod 755 /tmp/layer/controller
      cp /etc/ssl/certs/ca-certificates.crt /tmp/layer/etc/ssl/certs/
      tar -cf /tmp/layer.tar -C /tmp/layer .

      # Push with platform version tag and latest
      REPO="ghcr.io/groblegark/gastown/agent-controller"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config (entrypoint, user) to match image-controller
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --entrypoint /controller \
        --user 65534 \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ── Push agent image to GHCR ──────────────────────────────────────────
  - key: push-agent
    use: [code, build-gt, download-coop, download-bd]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      # Install Node.js into layer tree (version from .node-version)
      NODE_VERSION=$(cat .node-version)
      mkdir -p /tmp/layer/usr/local
      curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
        | tar -xJ --strip-components=1 -C /tmp/layer/usr/local

      # Install Claude Code
      PATH="/tmp/layer/usr/local/bin:$PATH" npm install -g --prefix /tmp/layer/usr/local @anthropic-ai/claude-code

      # Install system packages (git, curl, jq, screen, icu) into the layer.
      # The RWX VM is Ubuntu-based so we can apt-get install, then copy
      # the installed files into the layer tree.
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends \
        git curl jq screen ca-certificates libicu74

      # Extract installed package file lists and copy into layer.
      # Use dpkg -L for known packages, plus ldd for transitive shared libs.
      mkdir -p /tmp/layer
      for pkg in git git-man curl jq screen ca-certificates libicu74 \
          liberror-perl libcurl4t64 libnghttp2-14 libbrotli1 \
          libpsl5t64 libonig5 libexpat1; do
        dpkg -L "$pkg" 2>/dev/null | while read -r f; do
          [ -f "$f" ] || continue
          dir="/tmp/layer$(dirname "$f")"
          mkdir -p "$dir"
          cp "$f" "/tmp/layer${f}"
        done
      done
      # Also copy shared libs that git/curl/bd link against
      for bin in /usr/bin/git /usr/bin/curl /usr/bin/jq /usr/bin/screen; do
        ldd "$bin" 2>/dev/null | grep "=> /" | awk '{print $3}' | while read -r lib; do
          [ -f "$lib" ] || continue
          dir="/tmp/layer$(dirname "$lib")"
          mkdir -p "$dir"
          cp -n "$lib" "/tmp/layer${lib}" 2>/dev/null || true
        done
      done
      # Copy ICU data and libs (needed by bd binary for unicode normalization)
      find /usr/lib/x86_64-linux-gnu -name 'libicu*.so*' 2>/dev/null | while read -r f; do
        dir="/tmp/layer$(dirname "$f")"
        mkdir -p "$dir"
        cp -a "$f" "/tmp/layer${f}"
      done
      # Copy git-core helpers
      cp -r /usr/lib/git-core /tmp/layer/usr/lib/ 2>/dev/null || true

      # Install binaries
      mkdir -p /tmp/layer/usr/local/bin
      cp ${{ tasks.build-gt.artifacts.gt-binary }} /tmp/layer/usr/local/bin/gt
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop /tmp/layer/usr/local/bin/coop
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop-mux /tmp/layer/usr/local/bin/coop-mux 2>/dev/null || true
      cp ${{ tasks.download-bd.artifacts.bd-binaries }}/bd /tmp/layer/usr/local/bin/bd
      ln -sf coop-mux /tmp/layer/usr/local/bin/coopmux
      chmod +x /tmp/layer/usr/local/bin/gt /tmp/layer/usr/local/bin/coop \
        /tmp/layer/usr/local/bin/bd /tmp/layer/usr/local/bin/coop-mux 2>/dev/null || true

      # Install entrypoint
      cp deploy/agent/entrypoint.sh /tmp/layer/entrypoint.sh
      chmod +x /tmp/layer/entrypoint.sh

      # Write platform version for runtime discovery
      mkdir -p /tmp/layer/etc
      echo "${PLATFORM_VERSION}" > /tmp/layer/etc/platform-version

      # Create home directory and user config
      mkdir -p /tmp/layer/home/agent/gt /tmp/layer/etc/ssl/certs
      cp /etc/ssl/certs/ca-certificates.crt /tmp/layer/etc/ssl/certs/

      tar -cf /tmp/layer.tar -C /tmp/layer .

      # Push with platform version tag and latest
      REPO="ghcr.io/groblegark/gastown/gastown-agent"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config (entrypoint, user, workdir) to match image-agent
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --entrypoint /entrypoint.sh \
        --user 1000 \
        --workdir /home/agent/gt \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ── Push toolchain image to GHCR ──────────────────────────────────────
  # NOTE: Toolchain is complex (apt packages, Go, Node, Python, AWS CLI, etc.).
  # This task builds the full layer from scratch on the RWX VM, including
  # apt packages installed into a chroot-like staging directory.
  # For simpler rebuilds, use: rwx image build -f .rwx/docker.yml \
  #   --target image-toolchain --push-to ghcr.io/groblegark/gastown/gastown-toolchain:latest
  - key: push-toolchain
    use: [code, build-gt, download-coop, download-bd]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env
      export DEBIAN_FRONTEND=noninteractive

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      # Install apt packages on the build VM, then snapshot the installed files.
      # The RWX VM runs ubuntu:24.04 (same as our base image), so package
      # paths are identical. We install, diff /usr, and include the delta.
      find /usr -type f > /tmp/before.txt
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends \
        git curl jq screen ca-certificates libicu74 \
        python3 python3-pip python3-venv make gcc g++ unzip
      find /usr -type f > /tmp/after.txt
      # Compute new files from apt install
      comm -13 <(sort /tmp/before.txt) <(sort /tmp/after.txt) > /tmp/apt-files.txt

      LAYER=/tmp/layer
      mkdir -p $LAYER

      # Copy apt-installed files into layer
      while IFS= read -r f; do
        dir="$LAYER$(dirname "$f")"
        mkdir -p "$dir"
        cp -a "$f" "$dir/"
      done < /tmp/apt-files.txt
      # Symlinks
      mkdir -p $LAYER/usr/bin
      ln -sf python3 $LAYER/usr/bin/python

      # CA certs
      mkdir -p $LAYER/etc/ssl/certs
      cp /etc/ssl/certs/ca-certificates.crt $LAYER/etc/ssl/certs/

      # Go (resolve latest patch from .go-version)
      GO_VERSION=$(cat .go-version)
      GO_LATEST=$(curl -fsSL "https://go.dev/dl/?mode=json" | jq -r "[.[] | select(.version | startswith(\"go${GO_VERSION}\"))][0].version")
      mkdir -p $LAYER/usr/local
      curl -fsSL "https://go.dev/dl/${GO_LATEST}.linux-amd64.tar.gz" | tar -C $LAYER/usr/local -xz
      # gopls (build using installed Go, output to layer)
      GOROOT=$LAYER/usr/local/go GOPATH=/tmp/gopath $LAYER/usr/local/go/bin/go install golang.org/x/tools/gopls@latest 2>/dev/null || true
      cp /tmp/gopath/bin/gopls $LAYER/usr/local/go/bin/ 2>/dev/null || true

      # Node.js (version from .node-version)
      NODE_VERSION=$(cat .node-version)
      curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
        | tar -xJ --strip-components=1 -C $LAYER/usr/local

      # Rust Analyzer
      mkdir -p $LAYER/usr/local/bin
      curl -fsSL "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" \
        | gunzip > $LAYER/usr/local/bin/rust-analyzer
      chmod +x $LAYER/usr/local/bin/rust-analyzer

      # kubectl
      KUBECTL_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
      curl -fsSL "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" \
        -o $LAYER/usr/local/bin/kubectl
      chmod +x $LAYER/usr/local/bin/kubectl

      # RWX CLI
      curl -fsSL "https://github.com/rwx-cloud/cli/releases/latest/download/rwx-linux-x86_64" \
        -o $LAYER/usr/local/bin/rwx
      chmod +x $LAYER/usr/local/bin/rwx

      # Docker CLI
      curl -fsSL "https://download.docker.com/linux/static/stable/x86_64/docker-27.5.1.tgz" | \
        tar -xz --strip-components=1 -C $LAYER/usr/local/bin docker/docker

      # AWS CLI
      curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
      unzip -q /tmp/awscli.zip -d /tmp
      mkdir -p $LAYER/opt/aws-cli
      /tmp/aws/install --install-dir $LAYER/opt/aws-cli --bin-dir $LAYER/opt/aws-cli/bin
      ln -sf /opt/aws-cli/bin/aws $LAYER/usr/local/bin/aws
      rm -rf /tmp/awscli.zip /tmp/aws

      # Install gt, coop, coopmux, bd binaries
      cp ${{ tasks.build-gt.artifacts.gt-binary }} $LAYER/usr/local/bin/gt
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop $LAYER/usr/local/bin/coop
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop-mux $LAYER/usr/local/bin/coop-mux 2>/dev/null || true
      cp ${{ tasks.download-bd.artifacts.bd-binaries }}/bd $LAYER/usr/local/bin/bd
      ln -sf coop-mux $LAYER/usr/local/bin/coopmux
      chmod +x $LAYER/usr/local/bin/gt $LAYER/usr/local/bin/coop \
        $LAYER/usr/local/bin/bd $LAYER/usr/local/bin/coop-mux 2>/dev/null || true

      # Platform version + entrypoint + home dir
      echo "${PLATFORM_VERSION}" > $LAYER/etc/platform-version
      cp docker/toolchain/entrypoint.sh $LAYER/usr/local/bin/toolchain-entrypoint.sh
      chmod +x $LAYER/usr/local/bin/toolchain-entrypoint.sh
      mkdir -p $LAYER/home/agent/gt

      tar -cf /tmp/layer.tar -C $LAYER .

      # Push with platform version tag and latest
      REPO="ghcr.io/groblegark/gastown/gastown-toolchain"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config (cmd, user, workdir) to match image-toolchain
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --cmd /usr/local/bin/toolchain-entrypoint.sh \
        --user 1000:1000 \
        --workdir /home/agent/gt \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ═══════════════════════════════════════════════════════════════════════
  # Helm auto-bump — update fics-helm-chart image tags after image pushes
  # ═══════════════════════════════════════════════════════════════════════

  - key: helm-bump
    use: [code, push-agent, push-controller, push-toolchain]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -e
      source platform-versions.env

      # Skip if no GitLab token configured
      if [ -z "${GITLAB_TOKEN}" ]; then
        echo "GITLAB_TOKEN not set — skipping helm auto-bump."
        echo "To enable, add GITLAB_TOKEN to the RWX vault."
        echo ""
        echo "Manual bump command:"
        echo "  cd ~/book/fics-helm-chart/charts/gastown"
        echo "  sed -i '' -E 's|tag: \"20[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}\\.[0-9]+\"|tag: \"${PLATFORM_VERSION}\"|g' values/gastown-next.yaml"
        echo "  git add values/gastown-next.yaml && git commit -m 'chore: bump to ${PLATFORM_VERSION}' && git push"
        exit 0
      fi

      # Clone fics-helm-chart
      git clone "https://oauth2:${GITLAB_TOKEN}@gitlab.com/PiHealth/CoreFICS/fics-helm-chart.git" /tmp/helm-chart
      cd /tmp/helm-chart

      # Update gastown-next values: replace all CalVer image tags with new PLATFORM_VERSION.
      VALUES="charts/gastown/values/gastown-next.yaml"
      if [ -f "$VALUES" ]; then
        # Replace tag: "YYYY.MM.DD.N" patterns
        sed -i -E "s|tag: \"20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+\"|tag: \"${PLATFORM_VERSION}\"|g" "$VALUES"
        # Replace inline image references with CalVer tags
        sed -i -E "s|gastown-toolchain:20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+|gastown-toolchain:${PLATFORM_VERSION}|g" "$VALUES"
        sed -i -E "s|gastown-agent:20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+|gastown-agent:${PLATFORM_VERSION}|g" "$VALUES"
        sed -i -E "s|agent-controller:20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+|agent-controller:${PLATFORM_VERSION}|g" "$VALUES"
      fi

      # Commit and push if there are changes
      git config user.name "gastown-ci"
      git config user.email "ci@gastown.dev"
      git add -A
      if git diff --cached --quiet; then
        echo "No helm changes needed — tags already at ${PLATFORM_VERSION}"
      else
        git commit -m "chore(gastown-next): auto-bump images to ${PLATFORM_VERSION} [trigger: ${REF_NAME}]"
        git push
        echo "Helm values updated to ${PLATFORM_VERSION}"
      fi
    env:
      GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      REF_NAME: ${{ init.ref-name }}

  # ═══════════════════════════════════════════════════════════════════════
  # Deploy to gastown-rwx — auto-deploy after every successful image push
  # ═══════════════════════════════════════════════════════════════════════

  - key: deploy-rwx
    use: [code, push-agent, push-controller, push-toolchain]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    timeout: 15m
    run: |
      set -ex
      source platform-versions.env

      # Skip if no AWS credentials configured
      if [ -z "${AWS_ACCESS_KEY_ID}" ]; then
        echo "AWS credentials not set — skipping deploy-rwx."
        echo "To enable, add E2E_AWS_ACCESS_KEY_ID and E2E_AWS_SECRET_ACCESS_KEY to the RWX vault."
        exit 0
      fi

      # ── Install tools ──────────────────────────────────────────────────
      # kubectl
      KUBE_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
      curl -fsSL "https://dl.k8s.io/release/${KUBE_VERSION}/bin/linux/amd64/kubectl" -o /tmp/kubectl
      sudo install /tmp/kubectl /usr/local/bin/kubectl

      # helm
      curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      # ── Configure kubeconfig ───────────────────────────────────────────
      # Install AWS CLI (minimal)
      curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
      unzip -q /tmp/awscli.zip -d /tmp
      sudo /tmp/aws/install
      aws eks update-kubeconfig --name "${EKS_CLUSTER}" --region us-east-1

      # ── Clone helm chart repo ──────────────────────────────────────────
      if [ -n "${GITLAB_TOKEN}" ]; then
        git clone --depth=1 "https://oauth2:${GITLAB_TOKEN}@gitlab.com/PiHealth/CoreFICS/fics-helm-chart.git" /tmp/helm-chart
      else
        echo "GITLAB_TOKEN not set — cannot clone helm chart. Skipping deploy."
        exit 0
      fi

      cd /tmp/helm-chart/charts/gastown

      # ── Build helm dependencies ────────────────────────────────────────
      echo "$GHCR_TOKEN" | helm registry login ghcr.io -u "$GITHUB_USER" --password-stdin
      helm dependency build ./

      # ── Deploy with --atomic (auto-rollback on failure) ────────────────
      NS="gastown-rwx"
      RELEASE="gastown-rwx"

      helm upgrade --install "$RELEASE" ./ \
        -n "$NS" --create-namespace \
        --values values.yaml \
        --values values/gastown-rwx.yaml \
        --set "gastown.bd-daemon.image.tag=${BEADS_VERSION}" \
        --set "gastown.coopBroker.image.tag=${PLATFORM_VERSION}" \
        --set "gastown.agentController.image.tag=${PLATFORM_VERSION}" \
        --set "gastown.agentController.agentImage.tag=${PLATFORM_VERSION}" \
        --set "gastown.agentController.sidecarProfiles.toolchain-full.image=ghcr.io/groblegark/gastown/gastown-toolchain:${PLATFORM_VERSION}" \
        --atomic --timeout 10m \
        --wait

      echo "Deployed ${RELEASE} to ${NS} with platform version ${PLATFORM_VERSION}"

      # ── Health check ───────────────────────────────────────────────────
      echo "Checking pod health..."
      kubectl get pods -n "$NS" -o wide
      kubectl wait --for=condition=Ready pods -l app.kubernetes.io/component=daemon -n "$NS" --timeout=120s || true

      echo ""
      echo "Deploy complete: ${NS} → platform ${PLATFORM_VERSION}"
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.E2E_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.E2E_AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      EKS_CLUSTER: ${{ secrets.E2E_EKS_CLUSTER }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}
      GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
