# OCI image builds for gastown services — RWX native (no Dockerfiles).
#
# Uses $RWX_IMAGE for image metadata instead of inline Dockerfiles.
# The build VM uses rwx/base 1.0.0; the $RWX_IMAGE output defines
# the final container filesystem and metadata.
#
# Architecture:
#   build-* tasks → compile binaries as artifacts (cached by filters)
#   image-*  tasks → install runtime deps + configure $RWX_IMAGE metadata
#   push-*   tasks → crane-append layers to ubuntu:24.04, push to GHCR
#
# Push is automated on main/tags. For manual push of a single image:
#   rwx run .rwx/docker.yml --init commit-sha=$(git rev-parse HEAD) --target push-bd
#   rwx run .rwx/docker.yml --init commit-sha=$(git rev-parse HEAD) --target push-agent
#
# VERSIONING:
# All component versions are pinned in platform-versions.env (repo root).
# All images are tagged with PLATFORM_VERSION (CalVer: YYYY.MM.DD.N).
# To rebuild: bump versions in platform-versions.env, commit, run:
#   rwx run .rwx/docker.yml --init commit-sha=$(git rev-parse HEAD) --wait
#
# OPTIMIZATIONS:
# - Filter directives on Go mod downloads (cached by go.mod/go.sum)
# - Parallel builds with filter caching for dependency stability
# - RWX native layer caching replaces Docker BuildKit

on:
  github:
    push:
      if: ${{ event.git.branch == 'main' || starts-with(event.git.tag, 'v') }}
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: ${{ event.git.ref }}
        beads-version: ""
      status-checks:
        name: Docker
    pull_request:
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: pr
        beads-version: ""
      status-checks:
        - tasks: [build-gt, build-controller, download-coop, download-bd]
          name: Docker
  dispatch:
    - key: gastown-agent-rebuild
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: ${{ event.dispatch.params.trigger-source }}
        beads-version: ${{ event.dispatch.params.beads-version }}
        coop-version: ${{ event.dispatch.params.coop-version }}
      params:
        - key: trigger-source
          name: Trigger source
          description: What triggered the rebuild (e.g. coop-release, beads-release)
          default: manual
          required: false
        - key: beads-version
          name: Beads version
          description: Beads version tag to use (e.g. v0.62.7). Overrides platform-versions.env when set.
          default: ""
          required: false
        - key: coop-version
          name: Coop version
          description: Coop version tag to use (e.g. v0.12.4). Overrides platform-versions.env when set.
          default: ""
          required: false
      title: Agent rebuild (${{ init.ref-name }})
      # NOTE: No target — dispatch runs the full pipeline including push-* tasks.
      # Do NOT add "target: image-agent" here — it prevents GHCR pushes.
  cli:
    init:
      commit-sha: ${{ event.git.sha }}
      ref-name: cli
      beads-version: ""
      coop-version: ""

base:
  image: ubuntu:24.04
  config: rwx/base 1.0.0

tasks:
  # ═══════════════════════════════════════════════════════════════════════
  # Build tasks — compile and download in parallel, output binary artifacts
  # ═══════════════════════════════════════════════════════════════════════

  # ── Clone gastown repo ─────────────────────────────────────────────
  - key: code
    call: git/clone 2.0.3
    with:
      repository: https://github.com/groblegark/gastown.git
      ref: ${{ init.commit-sha }}

  # ── Go toolchain (version from .go-version) ───────────────────────
  - key: go
    call: golang/install 1.2.0
    with:
      go-version: "1.25"

  # ── Go mod download (cached by go.mod/go.sum) ──────────────────────
  - key: go-deps
    use: [code, go]
    run: go mod download
    filter:
      - go.mod
      - go.sum

  # ── Rust toolchain (cached, rebuild when lock changes) ──────────────
  - key: rust
    filter:
      - .rwx/rust-version.lock
    run: |
      echo "Installing Rust toolchain (should be cached)..."
      curl -fsSL --proto '=https' --tlsv1.2 https://sh.rustup.rs \
        | sh -s -- -y --default-toolchain 1.93.0

  # ── Build oj binary from oddjobs (cached, rebuild when lock changes) ─
  - key: build-oj
    use: rust
    filter:
      - .rwx/oj-version.lock
    run: |
      set -ex
      export PATH="$HOME/.cargo/bin:$PATH"
      echo "Building oj from source..."
      git clone --depth 1 --branch main https://github.com/groblegark/oddjobs.git /tmp/oj
      rm -f /tmp/oj/.cargo/config.toml
      RUSTC_WRAPPER="" cargo build --manifest-path /tmp/oj/Cargo.toml --release -p oj
      cp /tmp/oj/target/release/oj oj
    outputs:
      artifacts:
        - key: oj-binary
          path: oj

  # ── Build gt CLI binary → artifact ──────────────────────────────────
  # Reads GASTOWN_VERSION and PLATFORM_VERSION from platform-versions.env
  # for ldflags so `gt version` reports the correct version.
  - key: build-gt
    use: [go-deps]
    cache: false
    run: |
      source platform-versions.env
      CGO_ENABLED=0 GOOS=linux go build \
        -ldflags="-s -w \
          -X github.com/steveyegge/gastown/internal/cmd.Version=${GASTOWN_VERSION} \
          -X github.com/steveyegge/gastown/internal/cmd.Commit=${COMMIT_SHA} \
          -X github.com/steveyegge/gastown/internal/cmd.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
          -X github.com/steveyegge/gastown/internal/cmd.PlatformVersion=${PLATFORM_VERSION} \
          -X github.com/steveyegge/gastown/internal/cmd.BuiltProperly=1" \
        -o gt ./cmd/gt
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
    outputs:
      artifacts:
        - key: gt-binary
          path: gt

  # ── Build controller binary → artifact (separate Go module) ─────────
  - key: build-controller
    use: [code, go]
    run: |
      source platform-versions.env
      cd controller
      go mod download
      CGO_ENABLED=0 GOOS=linux go build \
        -ldflags="-s -w -X main.version=${PLATFORM_VERSION} -X main.commit=${COMMIT_SHA}" \
        -o ../controller-bin ./cmd/controller/
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
    filter:
      - controller/**/*.go
      - controller/go.mod
      - controller/go.sum
      - platform-versions.env
    outputs:
      artifacts:
        - key: controller-binary
          path: controller-bin

  # ── Download coop from releases → artifact (pinned by platform-versions.env) ─
  # When dispatched from a coop release, init.coop-version overrides the
  # pinned version so the agent image always gets the just-released binary.
  - key: download-coop
    use: code
    run: |
      set -ex
      source platform-versions.env
      # Dispatch override: use the version from the triggering coop release
      if [ -n "${COOP_VERSION_OVERRIDE}" ]; then
        COOP_VERSION="${COOP_VERSION_OVERRIDE}"
        echo "Using dispatch override: COOP_VERSION=${COOP_VERSION}"
      fi
      echo "Downloading coop ${COOP_VERSION} for linux-amd64"
      curl -fsSL "https://github.com/groblegark/coop/releases/download/${COOP_VERSION}/coop-linux-amd64.tar.gz" \
        -o /tmp/coop.tar.gz
      mkdir -p coop-bin
      tar -xzf /tmp/coop.tar.gz -C coop-bin
      ls -la coop-bin/
    env:
      COOP_VERSION_OVERRIDE: ${{ init.coop-version }}
    filter:
      - platform-versions.env
    outputs:
      artifacts:
        - key: coop-binaries
          path: coop-bin

  # ── Download bd from releases → artifact (pinned by platform-versions.env) ──
  # When dispatched from a beads release, init.beads-version overrides the
  # pinned version so the agent image always gets the just-released binary.
  - key: download-bd
    use: code
    run: |
      set -ex
      source platform-versions.env
      # Dispatch override: use the version from the triggering beads release
      if [ -n "${BEADS_VERSION_OVERRIDE}" ]; then
        BEADS_VERSION="${BEADS_VERSION_OVERRIDE}"
        echo "Using dispatch override: BEADS_VERSION=${BEADS_VERSION}"
      fi
      VERSION_NUM=${BEADS_VERSION#v}
      echo "Downloading bd ${BEADS_VERSION} for linux_amd64"
      curl -fsSL "https://github.com/groblegark/beads/releases/download/${BEADS_VERSION}/beads_${VERSION_NUM}_linux_amd64.tar.gz" \
        -o /tmp/bd.tar.gz
      mkdir -p bd-bin
      tar -xzf /tmp/bd.tar.gz -C bd-bin
      ls -la bd-bin/
    env:
      BEADS_VERSION_OVERRIDE: ${{ init.beads-version }}
    filter:
      - platform-versions.env
    outputs:
      artifacts:
        - key: bd-binaries
          path: bd-bin

  # ═══════════════════════════════════════════════════════════════════════
  # Image tasks — RWX native images via $RWX_IMAGE.
  # These define the container filesystem and metadata.
  # Push via: rwx image build -f .rwx/docker.yml --target <key> --push-to <registry>
  # ═══════════════════════════════════════════════════════════════════════

  # ── gt CLI image (ubuntu + git + binary) ───────────────────────────
  - key: image-gt
    use: [build-gt]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - cmd/gt/**/*.go
      - internal/**/*.go
      - go.mod
      - go.sum
    run: |
      # Install minimal runtime deps
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends ca-certificates git
      sudo apt-get clean
      sudo rm -rf /var/lib/apt/lists/*

      # Install binary
      sudo cp ${{ tasks.build-gt.artifacts.gt-binary }} /usr/local/bin/gt
      sudo chmod 755 /usr/local/bin/gt

      # Configure image metadata (no sudo needed)
      jq -n '["gt"]' > $RWX_IMAGE/entrypoint.json
      echo "1000" > $RWX_IMAGE/user

  # ── Controller image (minimal static binary) ───────────────────────
  - key: image-controller
    use: [build-controller]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - controller/**/*.go
      - controller/go.mod
      - controller/go.sum
    run: |
      # Install binary
      sudo cp ${{ tasks.build-controller.artifacts.controller-binary }} /controller
      sudo chmod 755 /controller

      # Configure image metadata
      jq -n '["/controller"]' > $RWX_IMAGE/entrypoint.json
      echo "65534" > $RWX_IMAGE/user

  # ── Agent image (rich: Go, Python, Rust Analyzer, kubectl, AWS, Docker + gt/coop/bd/claude) ──
  # Self-sufficient agent image — no toolchain sidecar needed.
  - key: image-agent
    use: [build-gt, download-coop, download-bd, build-oj, code]
    if: ${{ init.ref-name != 'pr' }}
    filter:
      - deploy/agent/entrypoint.sh
      - .node-version
      - .go-version
      - platform-versions.env
    run: |
      export DEBIAN_FRONTEND=noninteractive
      source platform-versions.env
      export PLATFORM_VERSION

      # Export artifact paths so sudo -E can pass them into the bash -c block.
      export GT_BIN="${{ tasks.build-gt.artifacts.gt-binary }}"
      export COOP_DIR="${{ tasks.download-coop.artifacts.coop-binaries }}"
      export BD_DIR="${{ tasks.download-bd.artifacts.bd-binaries }}"
      export OJ_BIN="${{ tasks.build-oj.artifacts.oj-binary }}"

      # Run ALL apt and sudo operations in a single sudo bash -c block.
      # WORKAROUND: dpkg operations (apt-get install) corrupt /etc/shadow
      # on RWX overlayfs, breaking subsequent sudo re-authentication.
      sudo -E bash -c '
        set -e

        # Base tools + dev stack
        apt-get -y update
        apt-get -y install --no-install-recommends \
          curl git jq make unzip ca-certificates screen \
          python3 python3-pip python3-venv \
          gcc g++ openssh-client libcurl3t64-gnutls sudo

        # Node.js (version from .node-version; binary tarball)
        NODE_VERSION=$(cat .node-version)
        curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
          | tar -xJ --strip-components=1 -C /usr/local

        # Go (version from .go-version, installer resolves latest patch)
        GO_VERSION=$(cat .go-version)
        GO_LATEST=$(curl -fsSL "https://go.dev/dl/?mode=json" | jq -r "[.[] | select(.version | startswith(\"go${GO_VERSION}\"))][0].version")
        curl -fsSL "https://go.dev/dl/${GO_LATEST}.linux-amd64.tar.gz" | tar -C /usr/local -xz
        export PATH="/usr/local/go/bin:$PATH"
        GOPATH="/tmp/go" go install golang.org/x/tools/gopls@latest
        mv /tmp/go/bin/gopls /usr/local/go/bin/gopls
        rm -rf /tmp/go

        # Python symlink
        ln -sf /usr/bin/python3 /usr/bin/python

        # Rust Analyzer
        curl -fsSL "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" | \
          gunzip | tee /usr/local/bin/rust-analyzer > /dev/null
        chmod +x /usr/local/bin/rust-analyzer

        # kubectl
        KUBECTL_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
        curl -fsSL "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" \
          -o /usr/local/bin/kubectl
        chmod +x /usr/local/bin/kubectl

        # RWX CLI
        curl -fsSL "https://github.com/rwx-cloud/cli/releases/latest/download/rwx-linux-x86_64" \
          -o /usr/local/bin/rwx
        chmod +x /usr/local/bin/rwx

        # Docker CLI (client only)
        curl -fsSL "https://download.docker.com/linux/static/stable/x86_64/docker-27.5.1.tgz" | \
          tar -xz --strip-components=1 -C /usr/local/bin docker/docker

        # AWS CLI
        curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
        unzip -q /tmp/awscli.zip -d /tmp
        /tmp/aws/install --install-dir /opt/aws-cli --bin-dir /usr/local/bin
        # Fix "current" symlink — installer resolves it relative to temp dir
        AWSVER=$(ls /opt/aws-cli/v2/ | grep -v current | head -1)
        ln -sfn "/opt/aws-cli/v2/${AWSVER}" /opt/aws-cli/v2/current
        rm -rf /tmp/awscli.zip /tmp/aws

        # Clean up apt
        apt-get clean
        rm -rf /var/lib/apt/lists/*

        # Install project binaries
        cp "${GT_BIN}" /usr/local/bin/gt
        cp "${COOP_DIR}/coop" /usr/local/bin/coop
        cp "${COOP_DIR}/coop-mux" /usr/local/bin/coop-mux 2>/dev/null || true
        cp "${BD_DIR}/bd" /usr/local/bin/bd
        cp "${OJ_BIN}" /usr/local/bin/oj
        ln -sf /usr/local/bin/coop-mux /usr/local/bin/coopmux
        chmod +x /usr/local/bin/gt /usr/local/bin/coop /usr/local/bin/bd \
          /usr/local/bin/oj /usr/local/bin/coop-mux 2>/dev/null || true

        # Claude Code
        npm install -g @anthropic-ai/claude-code

        # Write platform version for runtime discovery
        echo "${PLATFORM_VERSION}" > /etc/platform-version

        # Install entrypoint and create home dir
        cp deploy/agent/entrypoint.sh /entrypoint.sh
        chmod +x /entrypoint.sh
        mkdir -p /home/agent/gt
        chown -R 1000:1000 /home/agent

        # Rename ubuntu→agent in passwd/group
        sed -i "s/^ubuntu:/agent:/" /etc/passwd
        sed -i "s|/home/ubuntu|/home/agent|" /etc/passwd
        sed -i "s|/bin/sh|/bin/bash|" /etc/passwd
        sed -i "s/^ubuntu:/agent:/" /etc/group
      '

      # Configure image metadata (no sudo needed)
      jq -n '["/entrypoint.sh"]' > $RWX_IMAGE/entrypoint.json
      echo "agent" > $RWX_IMAGE/user
      echo "/home/agent/gt" > $RWX_IMAGE/workspace

  # ═══════════════════════════════════════════════════════════════════════
  # Push tasks — crane-append layers to ubuntu:24.04, push to GHCR.
  # Each push task reuses build artifacts to create a minimal OCI image.
  # Secrets: GHCR_TOKEN and GITHUB_USER must be set in the RWX vault.
  # ═══════════════════════════════════════════════════════════════════════

  # ── Push beads daemon image to GHCR ──────────────────────────────────
  # Publishes ghcr.io/groblegark/beads with CalVer tag. The beads repo
  # also pushes this image with semver tags (v0.62.7 etc.) via its own
  # image.yml — this task adds a CalVer alias so all images share a
  # single version number for deployment.
  - key: push-bd
    use: [code, download-bd, build-oj]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      # Install runtime deps — bd is CGO-linked and needs libicu at runtime
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends \
        ca-certificates libicu74 netcat-openbsd
      sudo rm -rf /var/lib/apt/lists/*

      # Build layer: bd + oj binaries + runtime deps
      LAYER=/tmp/layer
      mkdir -p $LAYER/usr/local/bin $LAYER/home/beads $LAYER/etc/ssl/certs

      cp ${{ tasks.download-bd.artifacts.bd-binaries }}/bd $LAYER/usr/local/bin/bd
      cp ${{ tasks.build-oj.artifacts.oj-binary }} $LAYER/usr/local/bin/oj
      chmod 755 $LAYER/usr/local/bin/bd $LAYER/usr/local/bin/oj

      # CA certificates (base ubuntu:24.04 doesn't include them)
      cp /etc/ssl/certs/ca-certificates.crt $LAYER/etc/ssl/certs/

      # libicu74 shared libraries (CGO dependency)
      dpkg -L libicu74 | grep '\.so' | while read -r lib; do
        dir="$LAYER$(dirname "$lib")"
        mkdir -p "$dir"
        cp -a "$lib" "$dir/"
      done

      tar -cf /tmp/layer.tar -C $LAYER .

      # Push with CalVer tag and latest
      REPO="ghcr.io/groblegark/beads"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config to match beads repo image-bd task
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --entrypoint bd \
        --cmd daemon --cmd start --cmd --foreground --cmd "--tcp-addr=:9876" --cmd "--http-addr=:9877" --cmd --log-json \
        --user 1000 \
        --workdir /home/beads \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ── Push controller image to GHCR ─────────────────────────────────────
  - key: push-controller
    use: [code, build-controller]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      # Build layer: static binary + CA certs
      mkdir -p /tmp/layer/etc/ssl/certs
      cp ${{ tasks.build-controller.artifacts.controller-binary }} /tmp/layer/controller
      chmod 755 /tmp/layer/controller
      cp /etc/ssl/certs/ca-certificates.crt /tmp/layer/etc/ssl/certs/
      tar -cf /tmp/layer.tar -C /tmp/layer .

      # Push with platform version tag and latest
      REPO="ghcr.io/groblegark/gastown/agent-controller"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config (entrypoint, user) to match image-controller
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --entrypoint /controller \
        --user 65534 \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ── Push agent image to GHCR ──────────────────────────────────────────
  # Rich agent image: includes full dev toolchain (Go, Python, Rust Analyzer,
  # kubectl, AWS CLI, Docker CLI, ssh) so agents are self-sufficient.
  - key: push-agent
    use: [code, build-gt, download-coop, download-bd, build-oj]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env
      export DEBIAN_FRONTEND=noninteractive

      # Install crane
      curl -fsSL "https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz" \
        | tar xz -C /tmp crane
      sudo mv /tmp/crane /usr/local/bin/

      # Login to GHCR
      echo "$GHCR_TOKEN" | crane auth login ghcr.io -u "$GITHUB_USER" --password-stdin

      LAYER=/tmp/layer
      mkdir -p $LAYER/usr/local/bin $LAYER/usr/local/go $LAYER/usr/bin

      # ── Node.js (version from .node-version) ──────────────────────────
      NODE_VERSION=$(cat .node-version)
      mkdir -p $LAYER/usr/local
      curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-x64.tar.xz" \
        | tar -xJ --strip-components=1 -C $LAYER/usr/local

      # Install Claude Code
      PATH="$LAYER/usr/local/bin:$PATH" npm install -g --prefix $LAYER/usr/local @anthropic-ai/claude-code

      # ── System packages ────────────────────────────────────────────────
      # Install on the build VM (same ubuntu:24.04 base), then copy files
      # into the layer tree.
      sudo apt-get -y update
      sudo apt-get -y install --no-install-recommends \
        git curl jq screen ca-certificates libicu74 \
        python3 python3-pip python3-venv \
        make gcc g++ unzip \
        openssh-client \
        libcurl3t64-gnutls sudo

      # Extract installed package file lists and copy into layer.
      # Skip files we can't read (e.g. /etc/sudoers is 0440) — the binaries
      # and libraries are the important parts, not config files.
      # IMPORTANT: Do NOT use sudo here — it creates root-owned dirs in $LAYER
      # that break subsequent non-sudo writes (Go, Node, kubectl, etc.).
      for pkg in git git-man curl jq screen ca-certificates libicu74 \
          liberror-perl libcurl4t64 libnghttp2-14 libbrotli1 \
          libpsl5t64 libonig5 libexpat1 \
          python3 python3-minimal python3.12 python3.12-minimal \
          python3-pip python3-venv python3.12-venv \
          libpython3.12-stdlib libpython3.12-minimal \
          make gcc g++ unzip \
          openssh-client libcurl3t64-gnutls sudo \
          libapparmor1; do
        dpkg -L "$pkg" 2>/dev/null | while read -r f; do
          [ -f "$f" ] || continue
          dir="$LAYER$(dirname "$f")"
          mkdir -p "$dir"
          cp "$f" "$LAYER${f}" 2>/dev/null || true
        done
      done
      # sudo config — create sudoers with correct ownership (root:root, 0440).
      # Uses printf to avoid '@' in heredoc (RWX YAML parser chokes on it).
      sudo mkdir -p $LAYER/etc/sudoers.d
      printf 'Defaults   env_reset\nDefaults   secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/go/bin"\nroot ALL=(ALL:ALL) ALL\n#includedir /etc/sudoers.d\n' | sudo tee $LAYER/etc/sudoers > /dev/null
      sudo chmod 0440 $LAYER/etc/sudoers
      printf 'ubuntu ALL=(ALL) NOPASSWD: ALL\n' | sudo tee $LAYER/etc/sudoers.d/agent > /dev/null
      sudo chmod 0440 $LAYER/etc/sudoers.d/agent
      # sudo.conf — must be owned by root
      sudo cp /etc/sudo.conf $LAYER/etc/sudo.conf 2>/dev/null || true
      # sudo helper libraries (libsudo_util.so etc.)
      mkdir -p $LAYER/usr/libexec/sudo
      cp /usr/libexec/sudo/*.so* $LAYER/usr/libexec/sudo/ 2>/dev/null || true

      # Also copy shared libs that key binaries link against
      for bin in /usr/bin/git /usr/bin/curl /usr/bin/jq /usr/bin/screen \
          /usr/bin/python3 /usr/bin/ssh /usr/bin/make /usr/bin/gcc \
          /usr/bin/sudo; do
        ldd "$bin" 2>/dev/null | grep "=> /" | awk '{print $3}' | while read -r lib; do
          [ -f "$lib" ] || continue
          dir="$LAYER$(dirname "$lib")"
          mkdir -p "$dir"
          cp -n "$lib" "$LAYER${lib}" 2>/dev/null || true
        done
      done
      # ICU data and libs (needed by bd binary for unicode normalization)
      find /usr/lib/x86_64-linux-gnu -name 'libicu*.so*' 2>/dev/null | while read -r f; do
        dir="$LAYER$(dirname "$f")"
        mkdir -p "$dir"
        cp -a "$f" "$LAYER${f}" 2>/dev/null || true
      done
      # git-core helpers (git-remote-https, etc.)
      cp -r /usr/lib/git-core $LAYER/usr/lib/ 2>/dev/null || true
      # libcurl-gnutls symlinks (git-remote-https requires this)
      find /usr/lib/x86_64-linux-gnu -name 'libcurl-gnutls*' 2>/dev/null | while read -r f; do
        dir="$LAYER$(dirname "$f")"
        mkdir -p "$dir"
        cp -a "$f" "$LAYER${f}" 2>/dev/null || true
      done
      # Python symlink
      mkdir -p $LAYER/usr/bin
      ln -sf python3 $LAYER/usr/bin/python

      # ── Go (version from .go-version + gopls) ─────────────────────────
      GO_VERSION=$(cat .go-version)
      GO_LATEST=$(curl -fsSL "https://go.dev/dl/?mode=json" | jq -r "[.[] | select(.version | startswith(\"go${GO_VERSION}\"))][0].version")
      curl -fsSL "https://go.dev/dl/${GO_LATEST}.linux-amd64.tar.gz" | tar -C $LAYER/usr/local -xz
      # Build gopls
      GOROOT=$LAYER/usr/local/go GOPATH=/tmp/gopath $LAYER/usr/local/go/bin/go install golang.org/x/tools/gopls@latest 2>/dev/null || true
      cp /tmp/gopath/bin/gopls $LAYER/usr/local/go/bin/ 2>/dev/null || true
      chmod -R u+w /tmp/gopath 2>/dev/null || true
      rm -rf /tmp/gopath
      # Symlink go binaries into /usr/local/bin (already in PATH for kubectl exec)
      ln -sf /usr/local/go/bin/go $LAYER/usr/local/bin/go
      ln -sf /usr/local/go/bin/gofmt $LAYER/usr/local/bin/gofmt
      ln -sf /usr/local/go/bin/gopls $LAYER/usr/local/bin/gopls

      # ── Rust Analyzer (LSP server) ────────────────────────────────────
      curl -fsSL "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" \
        | gunzip > $LAYER/usr/local/bin/rust-analyzer
      chmod +x $LAYER/usr/local/bin/rust-analyzer

      # ── kubectl ────────────────────────────────────────────────────────
      KUBECTL_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
      curl -fsSL "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" \
        -o $LAYER/usr/local/bin/kubectl
      chmod +x $LAYER/usr/local/bin/kubectl

      # ── RWX CLI ────────────────────────────────────────────────────────
      curl -fsSL "https://github.com/rwx-cloud/cli/releases/latest/download/rwx-linux-x86_64" \
        -o $LAYER/usr/local/bin/rwx
      chmod +x $LAYER/usr/local/bin/rwx

      # ── Docker CLI (client only) ──────────────────────────────────────
      curl -fsSL "https://download.docker.com/linux/static/stable/x86_64/docker-27.5.1.tgz" | \
        tar -xz --strip-components=1 -C $LAYER/usr/local/bin docker/docker

      # ── AWS CLI ────────────────────────────────────────────────────────
      # Install to a temp location first, then move into layer tree.
      # The installer creates symlinks with absolute paths — installing
      # directly into $LAYER produces broken symlinks pointing to /tmp/layer/...
      curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
      unzip -q /tmp/awscli.zip -d /tmp
      /tmp/aws/install --install-dir /tmp/aws-install --bin-dir /tmp/aws-bin
      mkdir -p $LAYER/opt/aws-cli
      # Copy AWS CLI but skip the "current" symlink (it points to build-time paths).
      # cp -r follows symlinks, so current/ becomes a dir copy — just delete and re-link.
      cp -r /tmp/aws-install/* $LAYER/opt/aws-cli/
      rm -rf $LAYER/opt/aws-cli/v2/current
      AWS_VER=$(ls $LAYER/opt/aws-cli/v2/ | head -1)
      ln -sf "$AWS_VER" $LAYER/opt/aws-cli/v2/current
      # Also fix the bin/ symlinks (they point to /tmp/aws-install/...)
      rm -rf $LAYER/opt/aws-cli/bin
      mkdir -p $LAYER/opt/aws-cli/bin
      ln -sf /opt/aws-cli/v2/current/bin/aws $LAYER/opt/aws-cli/bin/aws
      ln -sf /opt/aws-cli/v2/current/bin/aws_completer $LAYER/opt/aws-cli/bin/aws_completer
      # Symlink the aws binary into PATH
      ln -sf /opt/aws-cli/v2/current/bin/aws $LAYER/usr/local/bin/aws
      rm -rf /tmp/awscli.zip /tmp/aws /tmp/aws-install /tmp/aws-bin

      # ── Project binaries (gt, coop, bd, oj) ───────────────────────────
      cp ${{ tasks.build-gt.artifacts.gt-binary }} $LAYER/usr/local/bin/gt
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop $LAYER/usr/local/bin/coop
      cp ${{ tasks.download-coop.artifacts.coop-binaries }}/coop-mux $LAYER/usr/local/bin/coop-mux 2>/dev/null || true
      cp ${{ tasks.download-bd.artifacts.bd-binaries }}/bd $LAYER/usr/local/bin/bd
      cp ${{ tasks.build-oj.artifacts.oj-binary }} $LAYER/usr/local/bin/oj
      ln -sf coop-mux $LAYER/usr/local/bin/coopmux
      chmod +x $LAYER/usr/local/bin/gt $LAYER/usr/local/bin/coop \
        $LAYER/usr/local/bin/bd $LAYER/usr/local/bin/oj \
        $LAYER/usr/local/bin/coop-mux 2>/dev/null || true

      # ── Entrypoint + metadata ─────────────────────────────────────────
      cp deploy/agent/entrypoint.sh $LAYER/entrypoint.sh
      chmod +x $LAYER/entrypoint.sh

      mkdir -p $LAYER/etc $LAYER/etc/ssl/certs
      echo "${PLATFORM_VERSION}" > $LAYER/etc/platform-version
      cp /etc/ssl/certs/ca-certificates.crt $LAYER/etc/ssl/certs/

      # Home directory (owned by agent user)
      mkdir -p $LAYER/home/agent/gt

      # Fix ownership for sudo — must be root-owned with setuid bit.
      # The build user's copies lose root ownership; restore it here.
      sudo chown root:root $LAYER/usr/bin/sudo
      sudo chmod 4755 $LAYER/usr/bin/sudo
      sudo chown root:root $LAYER/etc/sudo.conf 2>/dev/null || true
      sudo chown root:root $LAYER/etc/sudoers.d
      # Make home dir owned by agent (UID 1000)
      sudo chown -R 1000:1000 $LAYER/home/agent

      sudo tar -cf /tmp/layer.tar -C $LAYER .

      # Push with platform version tag and latest
      REPO="ghcr.io/groblegark/gastown/gastown-agent"
      crane append --base ubuntu:24.04 --new_tag "${REPO}:${PLATFORM_VERSION}" --new_layer /tmp/layer.tar --platform linux/amd64

      # Set OCI image config (entrypoint, user, workdir)
      crane mutate "${REPO}:${PLATFORM_VERSION}" \
        --entrypoint /entrypoint.sh \
        --user 1000 \
        --workdir /home/agent/gt \
        -t "${REPO}:${PLATFORM_VERSION}"
      crane tag "${REPO}:${PLATFORM_VERSION}" latest
      echo "Pushed ${REPO}:${PLATFORM_VERSION} and ${REPO}:latest"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ═══════════════════════════════════════════════════════════════════════
  # Helm chart publish — publish bd-daemon + gastown charts with CalVer
  # ═══════════════════════════════════════════════════════════════════════

  # Publishes both charts to oci://ghcr.io/groblegark/charts with the same
  # CalVer tag as the images (PLATFORM_VERSION). This means a single version
  # number (e.g. 2026.02.17.13) identifies the exact image AND chart versions.
  #
  # The bd-daemon chart is cloned from the beads repo (its source of truth),
  # version overridden to CalVer, and published. The gastown chart's bd-daemon
  # dependency is also overridden to point to the CalVer bd-daemon chart.
  - key: helm-publish-charts
    use: code
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Convert CalVer YYYY.MM.DD.N → SemVer-compatible YYYY.MMDD.N
      # Helm requires valid SemVer (3 components). This encoding preserves
      # sort order and is clearly derived from the CalVer date.
      # Example: 2026.02.17.13 → 2026.217.13
      IFS='.' read -r YEAR MONTH DAY BUILD <<< "$PLATFORM_VERSION"
      CHART_VERSION="${YEAR}.${MONTH#0}${DAY}.${BUILD}"
      echo "Platform version: ${PLATFORM_VERSION} → chart version: ${CHART_VERSION}"

      # Install helm
      curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      # Login to GHCR
      echo "$GHCR_TOKEN" | helm registry login ghcr.io -u "$GITHUB_USER" --password-stdin

      mkdir -p /tmp/helm-packages

      # Clone beads repo (for bd-daemon chart source)
      git clone --depth=1 https://github.com/groblegark/beads.git /tmp/beads

      # ── Publish bd-daemon chart with CalVer ──────────────────────────────
      BD_CHART="/tmp/beads/helm/bd-daemon"
      echo "Overriding bd-daemon chart version to ${CHART_VERSION}"
      sed -i "s/^version:.*/version: ${CHART_VERSION}/" "$BD_CHART/Chart.yaml"
      sed -i "s/^appVersion:.*/appVersion: \"${PLATFORM_VERSION}\"/" "$BD_CHART/Chart.yaml"

      helm dependency build "$BD_CHART"
      helm package "$BD_CHART" --destination /tmp/helm-packages
      helm push "/tmp/helm-packages/bd-daemon-${CHART_VERSION}.tgz" "oci://ghcr.io/groblegark/charts"
      echo "Published bd-daemon:${CHART_VERSION}"

      # ── Publish gastown chart with CalVer ─────────────────────────────────
      GT_CHART="helm/gastown"
      echo "Overriding gastown chart version to ${CHART_VERSION}"
      sed -i "s/^version:.*/version: ${CHART_VERSION}/" "$GT_CHART/Chart.yaml"
      sed -i "s/^appVersion:.*/appVersion: \"${PLATFORM_VERSION}\"/" "$GT_CHART/Chart.yaml"

      # Point gastown's bd-daemon dependency at the CalVer version we just published.
      # Target only the indented version under dependencies (not the top-level version).
      sed -i -E "/name: bd-daemon/{n;s/version: \"[^\"]*\"/version: \"${CHART_VERSION}\"/}" "$GT_CHART/Chart.yaml"

      helm dependency update "$GT_CHART"
      helm package "$GT_CHART" --destination /tmp/helm-packages
      helm push "/tmp/helm-packages/gastown-${CHART_VERSION}.tgz" "oci://ghcr.io/groblegark/charts"
      echo "Published gastown:${CHART_VERSION}"
    env:
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}

  # ═══════════════════════════════════════════════════════════════════════
  # Helm auto-bump — update fics-helm-chart image tags + chart versions
  # ═══════════════════════════════════════════════════════════════════════

  - key: helm-bump
    use: [code, push-bd, push-agent, push-controller, helm-publish-charts]
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -e
      source platform-versions.env

      # Convert CalVer YYYY.MM.DD.N → SemVer YYYY.MMDD.N (same as helm-publish-charts)
      IFS='.' read -r YEAR MONTH DAY BUILD <<< "$PLATFORM_VERSION"
      CHART_VERSION="${YEAR}.${MONTH#0}${DAY}.${BUILD}"

      # Skip if no GitLab token configured
      if [ -z "${GITLAB_TOKEN}" ]; then
        echo "GITLAB_TOKEN not set — skipping helm auto-bump."
        echo "To enable, add GITLAB_TOKEN to the RWX vault."
        echo ""
        echo "Manual bump command:"
        echo "  cd ~/book/fics-helm-chart/charts/gastown"
        echo "  sed -i '' -E 's|tag: \"20[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}\\.[0-9]+\"|tag: \"${PLATFORM_VERSION}\"|g' values/gastown-next.yaml values/gastown-rwx.yaml"
        echo "  git add values/ && git commit -m 'chore: bump to ${PLATFORM_VERSION}' && git push"
        exit 0
      fi

      # Clone fics-helm-chart
      git clone "https://oauth2:${GITLAB_TOKEN}@gitlab.com/PiHealth/CoreFICS/fics-helm-chart.git" /tmp/helm-chart
      cd /tmp/helm-chart

      # Bump CalVer image tags in gastown values files.
      # Image tags use 4-component CalVer (PLATFORM_VERSION), not SemVer.
      bump_values() {
        local f="$1"
        if [ ! -f "$f" ]; then
          echo "Skipping $f (not found)"
          return
        fi
        echo "Bumping tags in $f"
        sed -i -E "s|tag: \"20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+\"|tag: \"${PLATFORM_VERSION}\"|g" "$f"
        sed -i -E "s|gastown-agent:20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+|gastown-agent:${PLATFORM_VERSION}|g" "$f"
        sed -i -E "s|agent-controller:20[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]+|agent-controller:${PLATFORM_VERSION}|g" "$f"
      }

      bump_values "charts/gastown/values/gastown-next.yaml"
      bump_values "charts/gastown/values/gastown-rwx.yaml"

      # Bump the outer gastown Chart.yaml to use SemVer-encoded CalVer charts.
      # Chart version/dependency use CHART_VERSION (3-component SemVer).
      # appVersion uses PLATFORM_VERSION (4-component CalVer, informational).
      OUTER_CHART="charts/gastown/Chart.yaml"
      if [ -f "$OUTER_CHART" ]; then
        echo "Bumping chart dependency in $OUTER_CHART → ${CHART_VERSION}"
        sed -i "s/^version:.*/version: ${CHART_VERSION}/" "$OUTER_CHART"
        sed -i "s/^appVersion:.*/appVersion: \"${PLATFORM_VERSION}\"/" "$OUTER_CHART"
        # Update gastown subchart dependency version (matches "~0.7.0" or any version string)
        sed -i -E "/name: gastown/{n;s/version: \"[^\"]*\"/version: \"${CHART_VERSION}\"/}" "$OUTER_CHART"
      fi

      # Commit and push if there are changes
      git config user.name "gastown-ci"
      git config user.email "matthew.baker@pihealth.ai"
      git add -A
      if git diff --cached --quiet; then
        echo "No helm changes needed — tags already at ${PLATFORM_VERSION}"
      else
        git commit -m "chore: auto-bump platform to ${PLATFORM_VERSION} [trigger: ${REF_NAME}]"
        git push
        echo "Helm chart + values updated to ${PLATFORM_VERSION}"
      fi
    env:
      GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
      REF_NAME: ${{ init.ref-name }}

  # ═══════════════════════════════════════════════════════════════════════
  # Deploy to gastown-rwx — auto-deploy after every successful image push
  # ═══════════════════════════════════════════════════════════════════════

  - key: deploy-rwx
    use: helm-bump
    if: ${{ init.ref-name != 'pr' }}
    cache: false
    run: |
      set -ex
      source platform-versions.env

      # Skip if no AWS credentials configured
      if [ -z "${AWS_ACCESS_KEY_ID}" ]; then
        echo "AWS credentials not set — skipping deploy-rwx."
        echo "To enable, add E2E_AWS_ACCESS_KEY_ID and E2E_AWS_SECRET_ACCESS_KEY to the RWX vault."
        exit 0
      fi

      # ── Install tools ──────────────────────────────────────────────────
      # kubectl
      KUBE_VERSION=$(curl -fsSL https://dl.k8s.io/release/stable.txt)
      curl -fsSL "https://dl.k8s.io/release/${KUBE_VERSION}/bin/linux/amd64/kubectl" -o /tmp/kubectl
      sudo install /tmp/kubectl /usr/local/bin/kubectl

      # helm
      curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      # ── Configure kubeconfig ───────────────────────────────────────────
      # Install AWS CLI (minimal)
      curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscli.zip
      unzip -q /tmp/awscli.zip -d /tmp
      sudo /tmp/aws/install
      aws eks update-kubeconfig --name "${EKS_CLUSTER}" --region us-east-1

      # ── Helm chart repo (inherited from helm-bump, or fresh clone) ─────
      if [ -d /tmp/helm-chart ]; then
        echo "Reusing helm chart from helm-bump task"
      elif [ -n "${GITLAB_TOKEN}" ]; then
        git clone --depth=1 "https://oauth2:${GITLAB_TOKEN}@gitlab.com/PiHealth/CoreFICS/fics-helm-chart.git" /tmp/helm-chart
      else
        echo "GITLAB_TOKEN not set — cannot clone helm chart. Skipping deploy."
        exit 0
      fi

      cd /tmp/helm-chart/charts/gastown

      # ── Build helm dependencies ────────────────────────────────────────
      echo "$GHCR_TOKEN" | helm registry login ghcr.io -u "$GITHUB_USER" --password-stdin
      # Remove stale subchart dir and regenerate deps from updated Chart.yaml.
      # Use 'update' not 'build' — helm-bump changed the dependency version
      # so Chart.lock is out of sync.
      rm -rf charts/gastown
      helm dependency update ./

      # ── Deploy with retry on lock conflict ───────────────────────────────
      NS="gastown-rwx"
      RELEASE="gastown-rwx"

      # Concurrent pipeline runs can leave the Helm release in a stuck
      # pending-upgrade/pending-install state. Detect and recover.
      # Check for stuck release BEFORE deploying.
      STUCK=$(helm history "$RELEASE" -n "$NS" --max 1 -o json 2>/dev/null \
        | jq -r '.[0].status // "none"')
      if echo "$STUCK" | grep -qE "pending-(upgrade|install|rollback)"; then
        echo "Helm release is stuck in '${STUCK}' — rolling back..."
        LAST_GOOD=$(helm history "$RELEASE" -n "$NS" --max 20 -o json \
          | jq -r '[.[] | select(.status == "deployed")] | last | .revision')
        if [ -n "$LAST_GOOD" ] && [ "$LAST_GOOD" != "null" ]; then
          echo "Rolling back to last deployed revision: ${LAST_GOOD}"
          helm rollback "$RELEASE" "$LAST_GOOD" -n "$NS" --wait --timeout 5m
        else
          echo "No deployed revision found — rolling back to previous"
          helm rollback "$RELEASE" 0 -n "$NS" --wait --timeout 5m
        fi
      fi

      # Image tags are pinned in gastown-rwx.yaml (updated by helm-bump task).
      helm upgrade --install "$RELEASE" ./ \
        -n "$NS" --create-namespace \
        --values values.yaml \
        --values values/gastown-rwx.yaml \
        --atomic --timeout 10m \
        --wait

      echo "Deployed ${RELEASE} to ${NS} with platform version ${PLATFORM_VERSION}"

      # ── Health check ───────────────────────────────────────────────────
      echo "Checking pod health..."
      kubectl get pods -n "$NS" -o wide
      kubectl wait --for=condition=Ready pods -l app.kubernetes.io/component=daemon -n "$NS" --timeout=120s || true

      echo ""
      echo "Deploy complete: ${NS} → platform ${PLATFORM_VERSION}"
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.E2E_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.E2E_AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      EKS_CLUSTER: ${{ secrets.E2E_EKS_CLUSTER }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}
      GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
